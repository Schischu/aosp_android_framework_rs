/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/gen_runtime.

/** @file
 *
 */

#ifndef __rs_core_math_rsh__
#define __rs_core_math_rsh__
#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uchar __attribute__((const, overloadable))abs(char v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))abs(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))abs(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))abs(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern ushort __attribute__((const, overloadable))abs(short v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))abs(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))abs(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))abs(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uint __attribute__((const, overloadable))abs(int v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))abs(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))abs(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of an integer.
 *
 * For floats, use fabs().
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))abs(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))acos(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))acos(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))acos(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))acos(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))acosh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))acosh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))acosh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))acosh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))acospi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))acospi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))acospi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))acospi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))asin(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))asin(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))asin(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))asin(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))asinh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))asinh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))asinh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))asinh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))asinpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))asinpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))asinpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))asinpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))atan(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))atan(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))atan(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))atan(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))atan2(float numerator, float denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))atan2(float2 numerator, float2 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))atan2(float3 numerator, float3 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))atan2(float4 numerator, float4 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))atan2pi(float numerator, float denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))atan2pi(float2 numerator, float2 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))atan2pi(float3 numerator, float3 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent of (numerator / denominator), in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))atan2pi(float4 numerator, float4 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))atanh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))atanh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))atanh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))atanh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))atanpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))atanpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))atanpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))atanpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cube root.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))cbrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cube root.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))cbrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cube root.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))cbrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cube root.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))cbrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not less than a value.
 *
 * For example, ceil(1.2f) returns 2.f, and ceil(-1.2f) returns -1.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))ceil(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not less than a value.
 *
 * For example, ceil(1.2f) returns 2.f, and ceil(-1.2f) returns -1.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))ceil(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not less than a value.
 *
 * For example, ceil(1.2f) returns 2.f, and ceil(-1.2f) returns -1.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))ceil(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not less than a value.
 *
 * For example, ceil(1.2f) returns 2.f, and ceil(-1.2f) returns -1.f.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))ceil(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))clamp(float value, float min_value, float max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))clamp(float2 value, float2 min_value, float2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))clamp(float3 value, float3 min_value, float3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))clamp(float4 value, float4 min_value, float4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))clamp(float2 value, float min_value, float max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))clamp(float3 value, float min_value, float max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))clamp(float4 value, float min_value, float max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern char __attribute__((const, overloadable))clamp(char value, char min_value, char max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern char2 __attribute__((const, overloadable))clamp(char2 value, char2 min_value, char2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern char3 __attribute__((const, overloadable))clamp(char3 value, char3 min_value, char3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern char4 __attribute__((const, overloadable))clamp(char4 value, char4 min_value, char4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uchar __attribute__((const, overloadable))clamp(uchar value, uchar min_value, uchar max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uchar2 __attribute__((const, overloadable))clamp(uchar2 value, uchar2 min_value, uchar2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uchar3 __attribute__((const, overloadable))clamp(uchar3 value, uchar3 min_value, uchar3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uchar4 __attribute__((const, overloadable))clamp(uchar4 value, uchar4 min_value, uchar4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern short __attribute__((const, overloadable))clamp(short value, short min_value, short max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern short2 __attribute__((const, overloadable))clamp(short2 value, short2 min_value, short2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern short3 __attribute__((const, overloadable))clamp(short3 value, short3 min_value, short3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern short4 __attribute__((const, overloadable))clamp(short4 value, short4 min_value, short4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ushort __attribute__((const, overloadable))clamp(ushort value, ushort min_value, ushort max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ushort2 __attribute__((const, overloadable))clamp(ushort2 value, ushort2 min_value, ushort2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ushort3 __attribute__((const, overloadable))clamp(ushort3 value, ushort3 min_value, ushort3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ushort4 __attribute__((const, overloadable))clamp(ushort4 value, ushort4 min_value, ushort4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern int __attribute__((const, overloadable))clamp(int value, int min_value, int max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern int2 __attribute__((const, overloadable))clamp(int2 value, int2 min_value, int2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern int3 __attribute__((const, overloadable))clamp(int3 value, int3 min_value, int3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern int4 __attribute__((const, overloadable))clamp(int4 value, int4 min_value, int4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uint __attribute__((const, overloadable))clamp(uint value, uint min_value, uint max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uint2 __attribute__((const, overloadable))clamp(uint2 value, uint2 min_value, uint2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uint3 __attribute__((const, overloadable))clamp(uint3 value, uint3 min_value, uint3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uint4 __attribute__((const, overloadable))clamp(uint4 value, uint4 min_value, uint4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern long __attribute__((const, overloadable))clamp(long value, long min_value, long max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern long2 __attribute__((const, overloadable))clamp(long2 value, long2 min_value, long2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern long3 __attribute__((const, overloadable))clamp(long3 value, long3 min_value, long3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern long4 __attribute__((const, overloadable))clamp(long4 value, long4 min_value, long4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ulong __attribute__((const, overloadable))clamp(ulong value, ulong min_value, ulong max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ulong2 __attribute__((const, overloadable))clamp(ulong2 value, ulong2 min_value, ulong2 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ulong3 __attribute__((const, overloadable))clamp(ulong3 value, ulong3 min_value, ulong3 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ulong4 __attribute__((const, overloadable))clamp(ulong4 value, ulong4 min_value, ulong4 max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern char2 __attribute__((const, overloadable))clamp(char2 value, char min_value, char max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern char3 __attribute__((const, overloadable))clamp(char3 value, char min_value, char max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern char4 __attribute__((const, overloadable))clamp(char4 value, char min_value, char max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uchar2 __attribute__((const, overloadable))clamp(uchar2 value, uchar min_value, uchar max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uchar3 __attribute__((const, overloadable))clamp(uchar3 value, uchar min_value, uchar max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uchar4 __attribute__((const, overloadable))clamp(uchar4 value, uchar min_value, uchar max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern short2 __attribute__((const, overloadable))clamp(short2 value, short min_value, short max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern short3 __attribute__((const, overloadable))clamp(short3 value, short min_value, short max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern short4 __attribute__((const, overloadable))clamp(short4 value, short min_value, short max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ushort2 __attribute__((const, overloadable))clamp(ushort2 value, ushort min_value, ushort max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ushort3 __attribute__((const, overloadable))clamp(ushort3 value, ushort min_value, ushort max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ushort4 __attribute__((const, overloadable))clamp(ushort4 value, ushort min_value, ushort max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern int2 __attribute__((const, overloadable))clamp(int2 value, int min_value, int max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern int3 __attribute__((const, overloadable))clamp(int3 value, int min_value, int max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern int4 __attribute__((const, overloadable))clamp(int4 value, int min_value, int max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uint2 __attribute__((const, overloadable))clamp(uint2 value, uint min_value, uint max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uint3 __attribute__((const, overloadable))clamp(uint3 value, uint min_value, uint max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern uint4 __attribute__((const, overloadable))clamp(uint4 value, uint min_value, uint max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern long2 __attribute__((const, overloadable))clamp(long2 value, long min_value, long max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern long3 __attribute__((const, overloadable))clamp(long3 value, long min_value, long max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern long4 __attribute__((const, overloadable))clamp(long4 value, long min_value, long max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ulong2 __attribute__((const, overloadable))clamp(ulong2 value, ulong min_value, ulong max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ulong3 __attribute__((const, overloadable))clamp(ulong3 value, ulong min_value, ulong max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 19))
/**
 * Clamps a value to a specified high and low bound.
 *
 * clamp() returns min_value if value < min_value, max_value if value > max_value, otherwise value.
 *
 * If min_value is greater than max_value, the results are undefined.
 *
 * @param value Value to be clamped.  Supports 1, 2, 3, 4 components.
 * @param min_value Lower bound, must be scalar or matching vector.
 * @param max_value High bound, must match the type of low.
 *
 * Supported by API versions 19 and newer.
 */
extern ulong4 __attribute__((const, overloadable))clamp(ulong4 value, ulong min_value, ulong max_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern char __attribute__((const, overloadable))clz(char value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))clz(char2 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))clz(char3 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))clz(char4 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar __attribute__((const, overloadable))clz(uchar value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))clz(uchar2 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))clz(uchar3 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))clz(uchar4 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern short __attribute__((const, overloadable))clz(short value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))clz(short2 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))clz(short3 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))clz(short4 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort __attribute__((const, overloadable))clz(ushort value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))clz(ushort2 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))clz(ushort3 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))clz(ushort4 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern int __attribute__((const, overloadable))clz(int value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))clz(int2 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))clz(int3 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))clz(int4 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uint __attribute__((const, overloadable))clz(uint value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))clz(uint2 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))clz(uint3 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the number of leading 0-bits in a value.
 *
 * For example, clz((char)0x03) returns 5.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))clz(uint4 value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from float4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from char4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uchar4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from short4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from ushort4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from int4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Component wise conversion from uint4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 9 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to float2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))convert_float2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to float3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))convert_float3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to float4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))convert_float4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to char2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char2 __attribute__((const, overloadable))convert_char2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to char3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char3 __attribute__((const, overloadable))convert_char3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to char4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern char4 __attribute__((const, overloadable))convert_char4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to uchar2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar2 __attribute__((const, overloadable))convert_uchar2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to uchar3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar3 __attribute__((const, overloadable))convert_uchar3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to uchar4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar4 __attribute__((const, overloadable))convert_uchar4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to short2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short2 __attribute__((const, overloadable))convert_short2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to short3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short3 __attribute__((const, overloadable))convert_short3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to short4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern short4 __attribute__((const, overloadable))convert_short4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to ushort2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort2 __attribute__((const, overloadable))convert_ushort2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to ushort3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort3 __attribute__((const, overloadable))convert_ushort3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to ushort4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort4 __attribute__((const, overloadable))convert_ushort4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to int2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int2 __attribute__((const, overloadable))convert_int2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to int3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int3 __attribute__((const, overloadable))convert_int3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to int4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern int4 __attribute__((const, overloadable))convert_int4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(double2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(double3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from double4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(double4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(long2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(long3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from long4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(long4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong2 to uint2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint2 __attribute__((const, overloadable))convert_uint2(ulong2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong3 to uint3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint3 __attribute__((const, overloadable))convert_uint3(ulong3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ulong4 to uint4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern uint4 __attribute__((const, overloadable))convert_uint4(ulong4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint2 to double2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double2 __attribute__((const, overloadable))convert_double2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint3 to double3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double3 __attribute__((const, overloadable))convert_double3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint4 to double4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern double4 __attribute__((const, overloadable))convert_double4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint2 to long2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))convert_long2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint3 to long3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))convert_long3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint4 to long4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))convert_long4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from float4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(char2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(char3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from char4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(char4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(uchar2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(uchar3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uchar4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(uchar4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(short2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(short3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from short4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(short4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(ushort2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(ushort3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from ushort4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(ushort4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(int2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(int3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from int4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(int4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint2 to ulong2.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))convert_ulong2(uint2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint3 to ulong3.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))convert_ulong3(uint3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Component wise conversion from uint4 to ulong4.
 *
 * For the convert_* functions, conversions of floating point values to integer will truncate.
 * Conversions of numbers too large to fit the destination type yield undefined results.
 * For example, converting a float that contains 1.0e18 to a short is undefined.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))convert_ulong4(uint4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Copies the sign from sign_value to magnitude_value.
 *
 * The value returned is either magnitude_value or -magnitude_value.
 *
 * For example, copysign(4.0f, -2.7f) returns -4.0f and copysign(-4.0f, 2.7f) returns 4.0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))copysign(float magnitude_value, float sign_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Copies the sign from sign_value to magnitude_value.
 *
 * The value returned is either magnitude_value or -magnitude_value.
 *
 * For example, copysign(4.0f, -2.7f) returns -4.0f and copysign(-4.0f, 2.7f) returns 4.0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))copysign(float2 magnitude_value, float2 sign_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Copies the sign from sign_value to magnitude_value.
 *
 * The value returned is either magnitude_value or -magnitude_value.
 *
 * For example, copysign(4.0f, -2.7f) returns -4.0f and copysign(-4.0f, 2.7f) returns 4.0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))copysign(float3 magnitude_value, float3 sign_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Copies the sign from sign_value to magnitude_value.
 *
 * The value returned is either magnitude_value or -magnitude_value.
 *
 * For example, copysign(4.0f, -2.7f) returns -4.0f and copysign(-4.0f, 2.7f) returns 4.0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))copysign(float4 magnitude_value, float4 sign_value);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))cos(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))cos(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))cos(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))cos(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypebolic cosine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))cosh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypebolic cosine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))cosh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypebolic cosine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))cosh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypebolic cosine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))cosh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))cospi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))cospi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))cospi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))cospi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the cross product of two vectors.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))cross(float3 left_vector, float3 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the cross product of two vectors.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))cross(float4 left_vector, float4 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from radians to degrees.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))degrees(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from radians to degrees.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))degrees(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from radians to degrees.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))degrees(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from radians to degrees.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))degrees(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the distance between two points.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))distance(float left_vector, float right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the distance between two points.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))distance(float2 left_vector, float2 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the distance between two points.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))distance(float3 left_vector, float3 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the distance between two points.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))distance(float4 left_vector, float4 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the dot product of two vectors.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))dot(float left_vector, float right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the dot product of two vectors.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))dot(float2 left_vector, float2 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the dot product of two vectors.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))dot(float3 left_vector, float3 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the dot product of two vectors.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))dot(float4 left_vector, float4 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))erf(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))erf(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))erf(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))erf(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the complementary error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))erfc(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the complementary error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))erfc(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the complementary error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))erfc(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the complementary error function.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))erfc(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v, i.e. e ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))exp(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v, i.e. e ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))exp(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v, i.e. e ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))exp(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v, i.e. e ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))exp(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 10 raised to v, i.e. 10.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))exp10(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 10 raised to v, i.e. 10.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))exp10(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 10 raised to v, i.e. 10.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))exp10(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 10 raised to v, i.e. 10.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))exp10(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 2 raised to v, i.e. 2.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))exp2(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 2 raised to v, i.e. 2.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))exp2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 2 raised to v, i.e. 2.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))exp2(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 2 raised to v, i.e. 2.f ^ v.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))exp2(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v minus 1, i.e. (e ^ v) - 1.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))expm1(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v minus 1, i.e. (e ^ v) - 1.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))expm1(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v minus 1, i.e. (e ^ v) - 1.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))expm1(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns e raised to v minus 1, i.e. (e ^ v) - 1.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))expm1(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of the float v.
 *
 * For integers, use abs().
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))fabs(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of the float v.
 *
 * For integers, use abs().
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fabs(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of the float v.
 *
 * For integers, use abs().
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fabs(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the absolute value of the float v.
 *
 * For integers, use abs().
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fabs(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate distance between two points.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_distance(float left_vector, float right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate distance between two points.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_distance(float2 left_vector, float2 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate distance between two points.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_distance(float3 left_vector, float3 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate distance between two points.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_distance(float4 left_vector, float4 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate length of a vector.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_length(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate length of a vector.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_length(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate length of a vector.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_length(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Computes the approximate length of a vector.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_length(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Approximately normalizes a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))fast_normalize(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Approximately normalizes a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float2 __attribute__((const, overloadable))fast_normalize(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Approximately normalizes a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float3 __attribute__((const, overloadable))fast_normalize(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Approximately normalizes a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * The precision is what would be expected from doing the computation using 16 bit floating point values.
 *
 * Supported by API versions 17 and newer.
 */
extern float4 __attribute__((const, overloadable))fast_normalize(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive difference between two values.
 *
 * If a > b, returns (a - b) otherwise returns 0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))fdim(float a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive difference between two values.
 *
 * If a > b, returns (a - b) otherwise returns 0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fdim(float2 a, float2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive difference between two values.
 *
 * If a > b, returns (a - b) otherwise returns 0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fdim(float3 a, float3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive difference between two values.
 *
 * If a > b, returns (a - b) otherwise returns 0f.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fdim(float4 a, float4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not greater than a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))floor(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not greater than a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))floor(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not greater than a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))floor(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the smallest integer not greater than a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))floor(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to mad().
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))fma(float multiplicand1, float multiplicand2, float offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to mad().
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fma(float2 multiplicand1, float2 multiplicand2, float2 offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to mad().
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fma(float3 multiplicand1, float3 multiplicand2, float3 offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to mad().
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fma(float4 multiplicand1, float4 multiplicand2, float4 offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum of a and b, i.e. (a < b ? b : a).
 *
 * The max() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))fmax(float a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum of a and b, i.e. (a < b ? b : a).
 *
 * The max() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fmax(float2 a, float2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum of a and b, i.e. (a < b ? b : a).
 *
 * The max() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fmax(float3 a, float3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum of a and b, i.e. (a < b ? b : a).
 *
 * The max() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fmax(float4 a, float4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum of a and b, i.e. (a < b ? b : a).
 *
 * Unlike the other variants of fmax() and max(), this function compare each element of a to the scalar b.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fmax(float2 a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum of a and b, i.e. (a < b ? b : a).
 *
 * Unlike the other variants of fmax() and max(), this function compare each element of a to the scalar b.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fmax(float3 a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum of a and b, i.e. (a < b ? b : a).
 *
 * Unlike the other variants of fmax() and max(), this function compare each element of a to the scalar b.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fmax(float4 a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum of a and b, i.e. (a > b ? b : a).
 *
 * The min() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))fmin(float a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum of a and b, i.e. (a > b ? b : a).
 *
 * The min() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fmin(float2 a, float2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum of a and b, i.e. (a > b ? b : a).
 *
 * The min() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fmin(float3 a, float3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum of a and b, i.e. (a > b ? b : a).
 *
 * The min() function returns identical results but can be applied to more data types.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fmin(float4 a, float4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum of a and b, i.e. (a > b ? b : a)
 *
 * Unlike the other variants of fmin() and min(), this function compare each element of a to the scalar b.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fmin(float2 a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum of a and b, i.e. (a > b ? b : a)
 *
 * Unlike the other variants of fmin() and min(), this function compare each element of a to the scalar b.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fmin(float3 a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum of a and b, i.e. (a > b ? b : a)
 *
 * Unlike the other variants of fmin() and min(), this function compare each element of a to the scalar b.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fmin(float4 a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards zero.
 *
 * The function remainder() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))fmod(float numerator, float denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards zero.
 *
 * The function remainder() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))fmod(float2 numerator, float2 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards zero.
 *
 * The function remainder() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))fmod(float3 numerator, float3 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards zero.
 *
 * The function remainder() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))fmod(float4 numerator, float4 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * @param v Input value.
 * @param floor  If floor is not null, each element of floor will be set to the floor of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((overloadable))fract(float v, float* floor);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * @param v Input value.
 * @param floor  If floor is not null, each element of floor will be set to the floor of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((overloadable))fract(float2 v, float2* floor);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * @param v Input value.
 * @param floor  If floor is not null, each element of floor will be set to the floor of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((overloadable))fract(float3 v, float3* floor);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * @param v Input value.
 * @param floor  If floor is not null, each element of floor will be set to the floor of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((overloadable))fract(float4 v, float4* floor);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * Supported by API versions 9 and newer.
 */
static float __attribute__((const, overloadable))fract(float v) {
 float unused;
 return fract(v, &unused);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * Supported by API versions 9 and newer.
 */
static float2 __attribute__((const, overloadable))fract(float2 v) {
 float2 unused;
 return fract(v, &unused);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * Supported by API versions 9 and newer.
 */
static float3 __attribute__((const, overloadable))fract(float3 v) {
 float3 unused;
 return fract(v, &unused);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the positive fractional part of v, i.e. v - floor(v).
 *
 * For example, fract(1.3f, &val) returns 0.3f and sets val to 1.f.
 * fract(-1.3f, &val) returns 0.7f and sets val to -2.f.
 *
 * Supported by API versions 9 and newer.
 */
static float4 __attribute__((const, overloadable))fract(float4 v) {
 float4 unused;
 return fract(v, &unused);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the binary mantissa and exponent of v, e.g. v == mantissa * 2 ^ exponent.
 *
 * The mantissa is always between 0.5 (inclusive) and 1.0 (exclusive).
 * See ldexp() for the reverse operation.
 *
 * @param v Supports float, float2, float3, float4.
 * @param exponent  If exponent is not null, each element of exponent will be set to the exponent of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((overloadable))frexp(float v, int* exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the binary mantissa and exponent of v, e.g. v == mantissa * 2 ^ exponent.
 *
 * The mantissa is always between 0.5 (inclusive) and 1.0 (exclusive).
 * See ldexp() for the reverse operation.
 *
 * @param v Supports float, float2, float3, float4.
 * @param exponent  If exponent is not null, each element of exponent will be set to the exponent of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((overloadable))frexp(float2 v, int2* exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the binary mantissa and exponent of v, e.g. v == mantissa * 2 ^ exponent.
 *
 * The mantissa is always between 0.5 (inclusive) and 1.0 (exclusive).
 * See ldexp() for the reverse operation.
 *
 * @param v Supports float, float2, float3, float4.
 * @param exponent  If exponent is not null, each element of exponent will be set to the exponent of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((overloadable))frexp(float3 v, int3* exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the binary mantissa and exponent of v, e.g. v == mantissa * 2 ^ exponent.
 *
 * The mantissa is always between 0.5 (inclusive) and 1.0 (exclusive).
 * See ldexp() for the reverse operation.
 *
 * @param v Supports float, float2, float3, float4.
 * @param exponent  If exponent is not null, each element of exponent will be set to the exponent of the corresponding element of v.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((overloadable))frexp(float4 v, int4* exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate reciprocal of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))half_recip(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate reciprocal of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float2 __attribute__((const, overloadable))half_recip(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate reciprocal of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float3 __attribute__((const, overloadable))half_recip(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate reciprocal of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float4 __attribute__((const, overloadable))half_recip(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate value of (1.f / sqrt(value)).
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))half_rsqrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate value of (1.f / sqrt(value)).
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float2 __attribute__((const, overloadable))half_rsqrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate value of (1.f / sqrt(value)).
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float3 __attribute__((const, overloadable))half_rsqrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate value of (1.f / sqrt(value)).
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float4 __attribute__((const, overloadable))half_rsqrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate square root of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float __attribute__((const, overloadable))half_sqrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate square root of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float2 __attribute__((const, overloadable))half_sqrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate square root of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float3 __attribute__((const, overloadable))half_sqrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 17))
/**
 * Returns the approximate square root of a value.
 *
 * The precision is that of a 16 bit floating point value.
 *
 * Supported by API versions 17 and newer.
 */
extern float4 __attribute__((const, overloadable))half_sqrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypotenuse, i.e. sqrt(a * a + b * b).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))hypot(float a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypotenuse, i.e. sqrt(a * a + b * b).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))hypot(float2 a, float2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypotenuse, i.e. sqrt(a * a + b * b).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))hypot(float3 a, float3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hypotenuse, i.e. sqrt(a * a + b * b).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))hypot(float4 a, float4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * logb() is similar but returns a float.
 *
 * Supported by API versions 9 and newer.
 */
extern int __attribute__((const, overloadable))ilogb(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * logb() is similar but returns a float.
 *
 * Supported by API versions 9 and newer.
 */
extern int2 __attribute__((const, overloadable))ilogb(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * logb() is similar but returns a float.
 *
 * Supported by API versions 9 and newer.
 */
extern int3 __attribute__((const, overloadable))ilogb(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * logb() is similar but returns a float.
 *
 * Supported by API versions 9 and newer.
 */
extern int4 __attribute__((const, overloadable))ilogb(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the floating point created from the mantissa and exponent, i.e. (mantissa * 2 ^ exponent).
 *
 * See frexp() for the reverse operation.
 *
 * @param mantissa Supports float, float2, float3, and float4.
 * @param exponent Supports single component or matching vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))ldexp(float mantissa, int exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the floating point created from the mantissa and exponent, i.e. (mantissa * 2 ^ exponent).
 *
 * See frexp() for the reverse operation.
 *
 * @param mantissa Supports float, float2, float3, and float4.
 * @param exponent Supports single component or matching vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))ldexp(float2 mantissa, int2 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the floating point created from the mantissa and exponent, i.e. (mantissa * 2 ^ exponent).
 *
 * See frexp() for the reverse operation.
 *
 * @param mantissa Supports float, float2, float3, and float4.
 * @param exponent Supports single component or matching vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))ldexp(float3 mantissa, int3 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the floating point created from the mantissa and exponent, i.e. (mantissa * 2 ^ exponent).
 *
 * See frexp() for the reverse operation.
 *
 * @param mantissa Supports float, float2, float3, and float4.
 * @param exponent Supports single component or matching vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))ldexp(float4 mantissa, int4 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the floating point created from the mantissa and exponent, i.e. (mantissa * 2 ^ exponent).
 * See frexp() for the reverse operation.
 *
 * @param mantissa Supports float, float2, float3, and float4.
 * @param exponent Supports single component or matching vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))ldexp(float2 mantissa, int exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the floating point created from the mantissa and exponent, i.e. (mantissa * 2 ^ exponent).
 * See frexp() for the reverse operation.
 *
 * @param mantissa Supports float, float2, float3, and float4.
 * @param exponent Supports single component or matching vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))ldexp(float3 mantissa, int exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the floating point created from the mantissa and exponent, i.e. (mantissa * 2 ^ exponent).
 * See frexp() for the reverse operation.
 *
 * @param mantissa Supports float, float2, float3, and float4.
 * @param exponent Supports single component or matching vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))ldexp(float4 mantissa, int exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the length of a vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))length(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the length of a vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))length(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the length of a vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))length(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Computes the length of a vector.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))length(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))lgamma(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))lgamma(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))lgamma(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))lgamma(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Can also return the sign of the gamma function.
 *
 * @param v Input value.
 * @param sign_of_gamma  If sign is not null, each element of sign will be set to -1.f if the gamma of the corresponding element of v is negative, otherwise to 1.f.
 *
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((overloadable))lgamma(float v, int* sign_of_gamma);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Can also return the sign of the gamma function.
 *
 * @param v Input value.
 * @param sign_of_gamma  If sign is not null, each element of sign will be set to -1.f if the gamma of the corresponding element of v is negative, otherwise to 1.f.
 *
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((overloadable))lgamma(float2 v, int2* sign_of_gamma);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Can also return the sign of the gamma function.
 *
 * @param v Input value.
 * @param sign_of_gamma  If sign is not null, each element of sign will be set to -1.f if the gamma of the corresponding element of v is negative, otherwise to 1.f.
 *
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((overloadable))lgamma(float3 v, int3* sign_of_gamma);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of the absolute value of the gamma function, i.e. log(fabs(gamma(v))).
 *
 * Can also return the sign of the gamma function.
 *
 * @param v Input value.
 * @param sign_of_gamma  If sign is not null, each element of sign will be set to -1.f if the gamma of the corresponding element of v is negative, otherwise to 1.f.
 *
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((overloadable))lgamma(float4 v, int4* sign_of_gamma);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))log(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))log(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))log(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))log(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 10 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))log10(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 10 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))log10(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 10 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))log10(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 10 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))log10(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of (v + 1.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))log1p(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of (v + 1.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))log1p(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of (v + 1.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))log1p(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the natural logarithm of (v + 1.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))log1p(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 2 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))log2(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 2 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))log2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 2 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))log2(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base 2 logarithm.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))log2(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.f.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * ilogb() is similar but returns an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))logb(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.f.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * ilogb() is similar but returns an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))logb(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.f.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * ilogb() is similar but returns an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))logb(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the base two exponent of a value, where the mantissa is between 1.f (inclusive) and 2.f (exclusive).
 *
 * For example, ilogb(8.5f) returns 3.f.  Because of the difference in mantissa, this number is one less than
 * is returned by frexp().
 *
 * ilogb() is similar but returns an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))logb(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to fma().
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))mad(float multiplicand1, float multiplicand2, float offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to fma().
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))mad(float2 multiplicand1, float2 multiplicand2, float2 offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to fma().
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))mad(float3 multiplicand1, float3 multiplicand2, float3 offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Multiply and add.  Returns (multiplicand1 * multiplicand2) + offset.
 *
 * This function is identical to fma().
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))mad(float4 multiplicand1, float4 multiplicand2, float4 offset);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))max(float a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))max(float2 a, float2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))max(float3 a, float3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))max(float4 a, float4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char __attribute__((const, overloadable))max(char a, char b) {
 return (a > b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar __attribute__((const, overloadable))max(uchar a, uchar b) {
 return (a > b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short __attribute__((const, overloadable))max(short a, short b) {
 return (a > b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort __attribute__((const, overloadable))max(ushort a, ushort b) {
 return (a > b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int __attribute__((const, overloadable))max(int a, int b) {
 return (a > b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint __attribute__((const, overloadable))max(uint a, uint b) {
 return (a > b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char2 __attribute__((const, overloadable))max(char2 a, char2 b) {
 char2 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar2 __attribute__((const, overloadable))max(uchar2 a, uchar2 b) {
 uchar2 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short2 __attribute__((const, overloadable))max(short2 a, short2 b) {
 short2 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort2 __attribute__((const, overloadable))max(ushort2 a, ushort2 b) {
 ushort2 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int2 __attribute__((const, overloadable))max(int2 a, int2 b) {
 int2 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint2 __attribute__((const, overloadable))max(uint2 a, uint2 b) {
 uint2 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char3 __attribute__((const, overloadable))max(char3 a, char3 b) {
 char3 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar3 __attribute__((const, overloadable))max(uchar3 a, uchar3 b) {
 uchar3 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short3 __attribute__((const, overloadable))max(short3 a, short3 b) {
 short3 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort3 __attribute__((const, overloadable))max(ushort3 a, ushort3 b) {
 ushort3 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int3 __attribute__((const, overloadable))max(int3 a, int3 b) {
 int3 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint3 __attribute__((const, overloadable))max(uint3 a, uint3 b) {
 uint3 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char4 __attribute__((const, overloadable))max(char4 a, char4 b) {
 char4 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 tmp.w = (a.w > b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar4 __attribute__((const, overloadable))max(uchar4 a, uchar4 b) {
 uchar4 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 tmp.w = (a.w > b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short4 __attribute__((const, overloadable))max(short4 a, short4 b) {
 short4 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 tmp.w = (a.w > b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort4 __attribute__((const, overloadable))max(ushort4 a, ushort4 b) {
 ushort4 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 tmp.w = (a.w > b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int4 __attribute__((const, overloadable))max(int4 a, int4 b) {
 int4 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 tmp.w = (a.w > b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the maximum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint4 __attribute__((const, overloadable))max(uint4 a, uint4 b) {
 uint4 tmp;
 tmp.x = (a.x > b.x ? a.x : b.x);
 tmp.y = (a.y > b.y ? a.y : b.y);
 tmp.z = (a.z > b.z ? a.z : b.z);
 tmp.w = (a.w > b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char __attribute__((const, overloadable))max(char a, char b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char2 __attribute__((const, overloadable))max(char2 a, char2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char3 __attribute__((const, overloadable))max(char3 a, char3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char4 __attribute__((const, overloadable))max(char4 a, char4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar __attribute__((const, overloadable))max(uchar a, uchar b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar2 __attribute__((const, overloadable))max(uchar2 a, uchar2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar3 __attribute__((const, overloadable))max(uchar3 a, uchar3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar4 __attribute__((const, overloadable))max(uchar4 a, uchar4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short __attribute__((const, overloadable))max(short a, short b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short2 __attribute__((const, overloadable))max(short2 a, short2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short3 __attribute__((const, overloadable))max(short3 a, short3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short4 __attribute__((const, overloadable))max(short4 a, short4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort __attribute__((const, overloadable))max(ushort a, ushort b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort2 __attribute__((const, overloadable))max(ushort2 a, ushort2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort3 __attribute__((const, overloadable))max(ushort3 a, ushort3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort4 __attribute__((const, overloadable))max(ushort4 a, ushort4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int __attribute__((const, overloadable))max(int a, int b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int2 __attribute__((const, overloadable))max(int2 a, int2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int3 __attribute__((const, overloadable))max(int3 a, int3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int4 __attribute__((const, overloadable))max(int4 a, int4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint __attribute__((const, overloadable))max(uint a, uint b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint2 __attribute__((const, overloadable))max(uint2 a, uint2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint3 __attribute__((const, overloadable))max(uint3 a, uint3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint4 __attribute__((const, overloadable))max(uint4 a, uint4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long __attribute__((const, overloadable))max(long a, long b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))max(long2 a, long2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))max(long3 a, long3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))max(long4 a, long4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong __attribute__((const, overloadable))max(ulong a, ulong b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))max(ulong2 a, ulong2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))max(ulong3 a, ulong3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the maximum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))max(ulong4 a, ulong4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))min(float a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))min(float2 a, float2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))min(float3 a, float3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))min(float4 a, float4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char __attribute__((const, overloadable))min(char a, char b) {
 return (a < b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar __attribute__((const, overloadable))min(uchar a, uchar b) {
 return (a < b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short __attribute__((const, overloadable))min(short a, short b) {
 return (a < b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort __attribute__((const, overloadable))min(ushort a, ushort b) {
 return (a < b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int __attribute__((const, overloadable))min(int a, int b) {
 return (a < b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint __attribute__((const, overloadable))min(uint a, uint b) {
 return (a < b ? a : b);
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char2 __attribute__((const, overloadable))min(char2 a, char2 b) {
 char2 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar2 __attribute__((const, overloadable))min(uchar2 a, uchar2 b) {
 uchar2 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short2 __attribute__((const, overloadable))min(short2 a, short2 b) {
 short2 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort2 __attribute__((const, overloadable))min(ushort2 a, ushort2 b) {
 ushort2 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int2 __attribute__((const, overloadable))min(int2 a, int2 b) {
 int2 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint2 __attribute__((const, overloadable))min(uint2 a, uint2 b) {
 uint2 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char3 __attribute__((const, overloadable))min(char3 a, char3 b) {
 char3 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar3 __attribute__((const, overloadable))min(uchar3 a, uchar3 b) {
 uchar3 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short3 __attribute__((const, overloadable))min(short3 a, short3 b) {
 short3 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort3 __attribute__((const, overloadable))min(ushort3 a, ushort3 b) {
 ushort3 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int3 __attribute__((const, overloadable))min(int3 a, int3 b) {
 int3 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint3 __attribute__((const, overloadable))min(uint3 a, uint3 b) {
 uint3 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static char4 __attribute__((const, overloadable))min(char4 a, char4 b) {
 char4 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 tmp.w = (a.w < b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uchar4 __attribute__((const, overloadable))min(uchar4 a, uchar4 b) {
 uchar4 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 tmp.w = (a.w < b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static short4 __attribute__((const, overloadable))min(short4 a, short4 b) {
 short4 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 tmp.w = (a.w < b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static ushort4 __attribute__((const, overloadable))min(ushort4 a, ushort4 b) {
 ushort4 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 tmp.w = (a.w < b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static int4 __attribute__((const, overloadable))min(int4 a, int4 b) {
 int4 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 tmp.w = (a.w < b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9) && (RS_VERSION <= 20))
/**
 * Returns the minimum value of two arguments.
 *
 * Suppored by API versions 9 - 19
 */
static uint4 __attribute__((const, overloadable))min(uint4 a, uint4 b) {
 uint4 tmp;
 tmp.x = (a.x < b.x ? a.x : b.x);
 tmp.y = (a.y < b.y ? a.y : b.y);
 tmp.z = (a.z < b.z ? a.z : b.z);
 tmp.w = (a.w < b.w ? a.w : b.w);
 return tmp;
}
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char __attribute__((const, overloadable))min(char a, char b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char2 __attribute__((const, overloadable))min(char2 a, char2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char3 __attribute__((const, overloadable))min(char3 a, char3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern char4 __attribute__((const, overloadable))min(char4 a, char4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar __attribute__((const, overloadable))min(uchar a, uchar b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar2 __attribute__((const, overloadable))min(uchar2 a, uchar2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar3 __attribute__((const, overloadable))min(uchar3 a, uchar3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uchar4 __attribute__((const, overloadable))min(uchar4 a, uchar4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short __attribute__((const, overloadable))min(short a, short b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short2 __attribute__((const, overloadable))min(short2 a, short2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short3 __attribute__((const, overloadable))min(short3 a, short3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern short4 __attribute__((const, overloadable))min(short4 a, short4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort __attribute__((const, overloadable))min(ushort a, ushort b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort2 __attribute__((const, overloadable))min(ushort2 a, ushort2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort3 __attribute__((const, overloadable))min(ushort3 a, ushort3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ushort4 __attribute__((const, overloadable))min(ushort4 a, ushort4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int __attribute__((const, overloadable))min(int a, int b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int2 __attribute__((const, overloadable))min(int2 a, int2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int3 __attribute__((const, overloadable))min(int3 a, int3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern int4 __attribute__((const, overloadable))min(int4 a, int4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint __attribute__((const, overloadable))min(uint a, uint b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint2 __attribute__((const, overloadable))min(uint2 a, uint2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint3 __attribute__((const, overloadable))min(uint3 a, uint3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern uint4 __attribute__((const, overloadable))min(uint4 a, uint4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long __attribute__((const, overloadable))min(long a, long b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long2 __attribute__((const, overloadable))min(long2 a, long2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long3 __attribute__((const, overloadable))min(long3 a, long3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern long4 __attribute__((const, overloadable))min(long4 a, long4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong __attribute__((const, overloadable))min(ulong a, ulong b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong2 __attribute__((const, overloadable))min(ulong2 a, ulong2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong3 __attribute__((const, overloadable))min(ulong3 a, ulong3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the minimum value of two arguments.
 *
 * Supported by API versions 21 and newer.
 */
extern ulong4 __attribute__((const, overloadable))min(ulong4 a, ulong4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns start + ((stop - start) * fraction).
 *
 * This can be useful for mixing two values.  For example, to create a new color that is 40% color1 and 60% color2, use mix(color1, color2, 0.6f).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))mix(float start, float stop, float fraction);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns start + ((stop - start) * fraction).
 *
 * This can be useful for mixing two values.  For example, to create a new color that is 40% color1 and 60% color2, use mix(color1, color2, 0.6f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))mix(float2 start, float2 stop, float2 fraction);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns start + ((stop - start) * fraction).
 *
 * This can be useful for mixing two values.  For example, to create a new color that is 40% color1 and 60% color2, use mix(color1, color2, 0.6f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))mix(float3 start, float3 stop, float3 fraction);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns start + ((stop - start) * fraction).
 *
 * This can be useful for mixing two values.  For example, to create a new color that is 40% color1 and 60% color2, use mix(color1, color2, 0.6f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))mix(float4 start, float4 stop, float4 fraction);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns start + ((stop - start) * fraction).
 *
 * This can be useful for mixing two values.  For example, to create a new color that is 40% color1 and 60% color2, use mix(color1, color2, 0.6f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))mix(float2 start, float2 stop, float fraction);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns start + ((stop - start) * fraction).
 *
 * This can be useful for mixing two values.  For example, to create a new color that is 40% color1 and 60% color2, use mix(color1, color2, 0.6f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))mix(float3 start, float3 stop, float fraction);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns start + ((stop - start) * fraction).
 *
 * This can be useful for mixing two values.  For example, to create a new color that is 40% color1 and 60% color2, use mix(color1, color2, 0.6f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))mix(float4 start, float4 stop, float fraction);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the integral and fractional components of a number.
 *
 * Both components will have the same sign as x.  For example, for an input of -3.72f, iret will be set to -3.f and .72f will be returned.
 *
 * @param v Source value
 * @param integral_part integral_part[0] will be set to the integral portion of the number.
 * @return The floating point portion of the value.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((overloadable))modf(float v, float* integral_part);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the integral and fractional components of a number.
 *
 * Both components will have the same sign as x.  For example, for an input of -3.72f, iret will be set to -3.f and .72f will be returned.
 *
 * @param v Source value
 * @param integral_part integral_part[0] will be set to the integral portion of the number.
 * @return The floating point portion of the value.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((overloadable))modf(float2 v, float2* integral_part);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the integral and fractional components of a number.
 *
 * Both components will have the same sign as x.  For example, for an input of -3.72f, iret will be set to -3.f and .72f will be returned.
 *
 * @param v Source value
 * @param integral_part integral_part[0] will be set to the integral portion of the number.
 * @return The floating point portion of the value.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((overloadable))modf(float3 v, float3* integral_part);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the integral and fractional components of a number.
 *
 * Both components will have the same sign as x.  For example, for an input of -3.72f, iret will be set to -3.f and .72f will be returned.
 *
 * @param v Source value
 * @param integral_part integral_part[0] will be set to the integral portion of the number.
 * @return The floating point portion of the value.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((overloadable))modf(float4 v, float4* integral_part);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns a NaN value (Not a Number).
 *
 * @param v Not used.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))nan(uint v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_acos(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_acos(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_acos(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_acos(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_acosh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_acosh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_acosh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic cosine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_acosh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_acospi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_acospi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_acospi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse cosine in radians, divided by pi.
 *
 * To get an inverse cosine measured in degrees, use acospi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_acospi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_asin(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_asin(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_asin(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_asin(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_asinh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_asinh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_asinh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic sine, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_asinh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_asinpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_asinpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_asinpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse sine in radians, divided by pi.
 *
 * To get an inverse sine measured in degrees, use asinpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_asinpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_atan(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_atan(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_atan(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_atan(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_atan2(float numerator, float denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_atan2(float2 numerator, float2 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_atan2(float3 numerator, float3 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_atan2(float4 numerator, float4 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_atan2pi(float numerator, float denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_atan2pi(float2 numerator, float2 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_atan2pi(float3 numerator, float3 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent of numerator / denominator, in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atan2pi(n, d) * 180.f.
 *
 * denominator can be 0.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_atan2pi(float4 numerator, float4 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_atanh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_atanh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_atanh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse hyperbolic tangent, in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_atanh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_atanpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_atanpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_atanpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate inverse tangent in radians, divided by pi.
 *
 * To get an inverse tangent measured in degrees, use atanpi(a) * 180.f.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_atanpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cubic root.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_cbrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cubic root.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_cbrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cubic root.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_cbrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cubic root.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_cbrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_cos(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_cos(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_cos(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_cos(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hypebolic cosine.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_cosh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hypebolic cosine.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_cosh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hypebolic cosine.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_cosh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hypebolic cosine.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_cosh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_cospi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_cospi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_cospi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate cosine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the cosine of a value measured in degrees, call cospi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_cospi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate distance between two points.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_distance(float left_vector, float right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate distance between two points.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_distance(float2 left_vector, float2 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate distance between two points.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_distance(float3 left_vector, float3 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate distance between two points.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_distance(float4 left_vector, float4 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate division result of two values.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_divide(float left_vector, float right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate division result of two values.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_divide(float2 left_vector, float2 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate division result of two values.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_divide(float3 left_vector, float3 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Computes the approximate division result of two values.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_divide(float4 left_vector, float4 right_vector);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp.
 *
 * It is valid for inputs from -86.f to 86.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float __attribute__((const, overloadable))native_exp(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp.
 *
 * It is valid for inputs from -86.f to 86.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float2 __attribute__((const, overloadable))native_exp(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp.
 *
 * It is valid for inputs from -86.f to 86.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float3 __attribute__((const, overloadable))native_exp(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp.
 *
 * It is valid for inputs from -86.f to 86.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float4 __attribute__((const, overloadable))native_exp(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp10.
 *
 * It is valid for inputs from -37.f to 37.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float __attribute__((const, overloadable))native_exp10(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp10.
 *
 * It is valid for inputs from -37.f to 37.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float2 __attribute__((const, overloadable))native_exp10(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp10.
 *
 * It is valid for inputs from -37.f to 37.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float3 __attribute__((const, overloadable))native_exp10(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp10.
 *
 * It is valid for inputs from -37.f to 37.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float4 __attribute__((const, overloadable))native_exp10(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp2.
 *
 * It is valid for inputs from -125.f to 125.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float __attribute__((const, overloadable))native_exp2(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp2.
 *
 * It is valid for inputs from -125.f to 125.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float2 __attribute__((const, overloadable))native_exp2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp2.
 *
 * It is valid for inputs from -125.f to 125.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float3 __attribute__((const, overloadable))native_exp2(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate exp2.
 *
 * It is valid for inputs from -125.f to 125.f.  The precision is no worse than what would be expected from using 16 bit floating point values.
 *
 * Supported by API versions 18 and newer.
 */
extern float4 __attribute__((const, overloadable))native_exp2(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate (e ^ v) - 1.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_expm1(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate (e ^ v) - 1.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_expm1(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate (e ^ v) - 1.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_expm1(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate (e ^ v) - 1.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_expm1(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate native_sqrt(a * a + b * b)
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_hypot(float a, float b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate native_sqrt(a * a + b * b)
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_hypot(float2 a, float2 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate native_sqrt(a * a + b * b)
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_hypot(float3 a, float3 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate native_sqrt(a * a + b * b)
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_hypot(float4 a, float4 b);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate length of a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_length(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate length of a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_length(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate length of a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_length(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate length of a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_length(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float __attribute__((const, overloadable))native_log(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float2 __attribute__((const, overloadable))native_log(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float3 __attribute__((const, overloadable))native_log(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float4 __attribute__((const, overloadable))native_log(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log10.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float __attribute__((const, overloadable))native_log10(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log10.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float2 __attribute__((const, overloadable))native_log10(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log10.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float3 __attribute__((const, overloadable))native_log10(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log10.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float4 __attribute__((const, overloadable))native_log10(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate natural logarithm of (v + 1.0f)
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_log1p(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate natural logarithm of (v + 1.0f)
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_log1p(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate natural logarithm of (v + 1.0f)
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_log1p(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate natural logarithm of (v + 1.0f)
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_log1p(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log2.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float __attribute__((const, overloadable))native_log2(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log2.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float2 __attribute__((const, overloadable))native_log2(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log2.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float3 __attribute__((const, overloadable))native_log2(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate log2.
 *
 * It is not accurate for values very close to zero.
 *
 * Supported by API versions 18 and newer.
 */
extern float4 __attribute__((const, overloadable))native_log2(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Approximately normalizes a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_normalize(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Approximately normalizes a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_normalize(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Approximately normalizes a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_normalize(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Approximately normalizes a vector.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_normalize(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate (base ^ exponent).
 *
 * @param base Must be between 0.f and 256.f.  The function is not accurate for values very close to zero.
 * @param exponent Must be between -15.f and 15.f.
 *
 * Supported by API versions 18 and newer.
 */
extern float __attribute__((const, overloadable))native_powr(float base, float exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate (base ^ exponent).
 *
 * @param base Must be between 0.f and 256.f.  The function is not accurate for values very close to zero.
 * @param exponent Must be between -15.f and 15.f.
 *
 * Supported by API versions 18 and newer.
 */
extern float2 __attribute__((const, overloadable))native_powr(float2 base, float2 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate (base ^ exponent).
 *
 * @param base Must be between 0.f and 256.f.  The function is not accurate for values very close to zero.
 * @param exponent Must be between -15.f and 15.f.
 *
 * Supported by API versions 18 and newer.
 */
extern float3 __attribute__((const, overloadable))native_powr(float3 base, float3 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 18))
/**
 * Fast approximate (base ^ exponent).
 *
 * @param base Must be between 0.f and 256.f.  The function is not accurate for values very close to zero.
 * @param exponent Must be between -15.f and 15.f.
 *
 * Supported by API versions 18 and newer.
 */
extern float4 __attribute__((const, overloadable))native_powr(float4 base, float4 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate approximate reciprocal of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_recip(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate approximate reciprocal of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_recip(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate approximate reciprocal of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_recip(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate approximate reciprocal of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_recip(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate Nth root of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_rootn(float v, int n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate Nth root of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_rootn(float2 v, int2 n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate Nth root of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_rootn(float3 v, int3 n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Compute the approximate Nth root of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_rootn(float4 v, int4 n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns approximate (1 / sqrt(v)).
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_rsqrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns approximate (1 / sqrt(v)).
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_rsqrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns approximate (1 / sqrt(v)).
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_rsqrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns approximate (1 / sqrt(v)).
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_rsqrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_sin(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_sin(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_sin(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_sin(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine and cosine of a value.
 *
 * @return sine
 * @param v The incoming value in radians
 * @param *cos cos[0] will be set to the cosine value.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((overloadable))native_sincos(float v, float* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine and cosine of a value.
 *
 * @return sine
 * @param v The incoming value in radians
 * @param *cos cos[0] will be set to the cosine value.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((overloadable))native_sincos(float2 v, float2* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine and cosine of a value.
 *
 * @return sine
 * @param v The incoming value in radians
 * @param *cos cos[0] will be set to the cosine value.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((overloadable))native_sincos(float3 v, float3* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine and cosine of a value.
 *
 * @return sine
 * @param v The incoming value in radians
 * @param *cos cos[0] will be set to the cosine value.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((overloadable))native_sincos(float4 v, float4* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic sine of a value specified in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_sinh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic sine of a value specified in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_sinh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic sine of a value specified in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_sinh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic sine of a value specified in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_sinh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_sinpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_sinpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_sinpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_sinpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sqrt(v).
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_sqrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sqrt(v).
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_sqrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sqrt(v).
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_sqrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate sqrt(v).
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_sqrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_tan(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_tan(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_tan(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of an angle measured in radians.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_tan(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic tangent of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_tanh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic tangent of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_tanh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic tangent of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_tanh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate hyperbolic tangent of a value.
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_tanh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float __attribute__((const, overloadable))native_tanpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))native_tanpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))native_tanpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns the approximate tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))native_tanpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the next floating point number from v towards target.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))nextafter(float v, float target);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the next floating point number from v towards target.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))nextafter(float2 v, float2 target);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the next floating point number from v towards target.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))nextafter(float3 v, float3 target);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the next floating point number from v towards target.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))nextafter(float4 v, float4 target);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Normalize a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))normalize(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Normalize a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))normalize(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Normalize a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))normalize(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Normalize a vector.
 *
 * For vectors of size 1, returns -1.f for negative values, 0.f for null values, and 1.f for positive values.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))normalize(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pown() and powr() are similar.  pown() takes an integer exponent. powr() assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))pow(float base, float exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pown() and powr() are similar.  pown() takes an integer exponent. powr() assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))pow(float2 base, float2 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pown() and powr() are similar.  pown() takes an integer exponent. powr() assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))pow(float3 base, float3 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pown() and powr() are similar.  pown() takes an integer exponent. powr() assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))pow(float4 base, float4 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pow() and powr() are similar.  The both take a float exponent. powr() also assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))pown(float base, int exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pow() and powr() are similar.  The both take a float exponent. powr() also assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))pown(float2 base, int2 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pow() and powr() are similar.  The both take a float exponent. powr() also assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))pown(float3 base, int3 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.
 *
 * pow() and powr() are similar.  The both take a float exponent. powr() also assumes the base to be non-negative.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))pown(float4 base, int4 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.  base must be >= 0.
 *
 * pow() and pown() are similar.  They both make no assumptions about the base.  pow() takes a float exponent while pown() take an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))powr(float base, float exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.  base must be >= 0.
 *
 * pow() and pown() are similar.  They both make no assumptions about the base.  pow() takes a float exponent while pown() take an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))powr(float2 base, float2 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.  base must be >= 0.
 *
 * pow() and pown() are similar.  They both make no assumptions about the base.  pow() takes a float exponent while pown() take an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))powr(float3 base, float3 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns base raised to the power exponent, i.e. base ^ exponent.  base must be >= 0.
 *
 * pow() and pown() are similar.  They both make no assumptions about the base.  pow() takes a float exponent while pown() take an integer.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))powr(float4 base, float4 exponent);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from degrees to radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))radians(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from degrees to radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))radians(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from degrees to radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))radians(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Converts from degrees to radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))radians(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards the nearest integer.
 *
 * The function fmod() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))remainder(float numerator, float denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards the nearest integer.
 *
 * The function fmod() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))remainder(float2 numerator, float2 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards the nearest integer.
 *
 * The function fmod() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))remainder(float3 numerator, float3 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the remainder of (numerator / denominator), where the quotient is rounded towards the nearest integer.
 *
 * The function fmod() is similar but rounds toward the closest interger.
 * For example, fmod(-3.8f, 2.f) returns -1.8f (-3.8f - -1.f * 2.f)
 * while remainder(-3.8f, 2.f) returns 0.2f (-3.8f - -2.f * 2.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))remainder(float4 numerator, float4 denominator);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the quotient and the remainder of (numerator / denominator).
 *
 * Only the sign and lowest three bits of the quotient are guaranteed to be accurate.
 *
 * This function is useful for implementing periodic functions.  The low three bits of the quotient gives the quadrant and the remainder the distance within the quadrant.  For example, an implementation of sin(x) could call remquo(x, PI / 2.f, &quadrant) to reduce very large value of x to something within a limited range.
 *
 * Example: remquo(-23.5f, 8.f, &quot) sets the lowest three bits of quot to 3 and the sign negative.  It returns 0.5f.
 *
 * @param numerator The numerator.
 * @param denominator The denominator.
 * @param *quotient quotient[0] will be set to the integer quotient.
 * @return The remainder, precise only for the low three bits.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((overloadable))remquo(float numerator, float denominator, int* quotient);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the quotient and the remainder of (numerator / denominator).
 *
 * Only the sign and lowest three bits of the quotient are guaranteed to be accurate.
 *
 * This function is useful for implementing periodic functions.  The low three bits of the quotient gives the quadrant and the remainder the distance within the quadrant.  For example, an implementation of sin(x) could call remquo(x, PI / 2.f, &quadrant) to reduce very large value of x to something within a limited range.
 *
 * Example: remquo(-23.5f, 8.f, &quot) sets the lowest three bits of quot to 3 and the sign negative.  It returns 0.5f.
 *
 * @param numerator The numerator.
 * @param denominator The denominator.
 * @param *quotient quotient[0] will be set to the integer quotient.
 * @return The remainder, precise only for the low three bits.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((overloadable))remquo(float2 numerator, float2 denominator, int2* quotient);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the quotient and the remainder of (numerator / denominator).
 *
 * Only the sign and lowest three bits of the quotient are guaranteed to be accurate.
 *
 * This function is useful for implementing periodic functions.  The low three bits of the quotient gives the quadrant and the remainder the distance within the quadrant.  For example, an implementation of sin(x) could call remquo(x, PI / 2.f, &quadrant) to reduce very large value of x to something within a limited range.
 *
 * Example: remquo(-23.5f, 8.f, &quot) sets the lowest three bits of quot to 3 and the sign negative.  It returns 0.5f.
 *
 * @param numerator The numerator.
 * @param denominator The denominator.
 * @param *quotient quotient[0] will be set to the integer quotient.
 * @return The remainder, precise only for the low three bits.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((overloadable))remquo(float3 numerator, float3 denominator, int3* quotient);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the quotient and the remainder of (numerator / denominator).
 *
 * Only the sign and lowest three bits of the quotient are guaranteed to be accurate.
 *
 * This function is useful for implementing periodic functions.  The low three bits of the quotient gives the quadrant and the remainder the distance within the quadrant.  For example, an implementation of sin(x) could call remquo(x, PI / 2.f, &quadrant) to reduce very large value of x to something within a limited range.
 *
 * Example: remquo(-23.5f, 8.f, &quot) sets the lowest three bits of quot to 3 and the sign negative.  It returns 0.5f.
 *
 * @param numerator The numerator.
 * @param denominator The denominator.
 * @param *quotient quotient[0] will be set to the integer quotient.
 * @return The remainder, precise only for the low three bits.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((overloadable))remquo(float4 numerator, float4 denominator, int4* quotient);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to the nearest integral value.
 *
 * rint() rounds half values to even.  For example, rint(0.5f) returns 0.f and rint(1.5f) returns 2.f.  Similarly, rint(-0.5f) returns -0.f and rint(-1.5f) returns -2.f.
 *
 * round() is similar but rounds away from zero.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))rint(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to the nearest integral value.
 *
 * rint() rounds half values to even.  For example, rint(0.5f) returns 0.f and rint(1.5f) returns 2.f.  Similarly, rint(-0.5f) returns -0.f and rint(-1.5f) returns -2.f.
 *
 * round() is similar but rounds away from zero.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))rint(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to the nearest integral value.
 *
 * rint() rounds half values to even.  For example, rint(0.5f) returns 0.f and rint(1.5f) returns 2.f.  Similarly, rint(-0.5f) returns -0.f and rint(-1.5f) returns -2.f.
 *
 * round() is similar but rounds away from zero.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))rint(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to the nearest integral value.
 *
 * rint() rounds half values to even.  For example, rint(0.5f) returns 0.f and rint(1.5f) returns 2.f.  Similarly, rint(-0.5f) returns -0.f and rint(-1.5f) returns -2.f.
 *
 * round() is similar but rounds away from zero.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))rint(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the Nth root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))rootn(float v, int n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the Nth root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))rootn(float2 v, int2 n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the Nth root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))rootn(float3 v, int3 n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Compute the Nth root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))rootn(float4 v, int4 n);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Round to the nearest integral value.
 *
 * round() rounds half values away from zero.  For example, round(0.5f) returns 1.f and round(1.5f) returns 2.f.  Similarly, round(-0.5f) returns -1.f and round(-1.5f) returns -2.f.
 *
 * rint() is similar but rounds half values toward even.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))round(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Round to the nearest integral value.
 *
 * round() rounds half values away from zero.  For example, round(0.5f) returns 1.f and round(1.5f) returns 2.f.  Similarly, round(-0.5f) returns -1.f and round(-1.5f) returns -2.f.
 *
 * rint() is similar but rounds half values toward even.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))round(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Round to the nearest integral value.
 *
 * round() rounds half values away from zero.  For example, round(0.5f) returns 1.f and round(1.5f) returns 2.f.  Similarly, round(-0.5f) returns -1.f and round(-1.5f) returns -2.f.
 *
 * rint() is similar but rounds half values toward even.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))round(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Round to the nearest integral value.
 *
 * round() rounds half values away from zero.  For example, round(0.5f) returns 1.f and round(1.5f) returns 2.f.  Similarly, round(-0.5f) returns -1.f and round(-1.5f) returns -2.f.
 *
 * rint() is similar but rounds half values toward even.  trunc() truncates the decimal fraction.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))round(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns (1 / sqrt(v)).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))rsqrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns (1 / sqrt(v)).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))rsqrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns (1 / sqrt(v)).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))rsqrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns (1 / sqrt(v)).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))rsqrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sign of a value.
 *
 * if (v < 0) return -1.f;
 * else if (v > 0) return 1.f;
 * else return 0.f;
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))sign(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sign of a value.
 *
 * if (v < 0) return -1.f;
 * else if (v > 0) return 1.f;
 * else return 0.f;
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))sign(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sign of a value.
 *
 * if (v < 0) return -1.f;
 * else if (v > 0) return 1.f;
 * else return 0.f;
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))sign(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sign of a value.
 *
 * if (v < 0) return -1.f;
 * else if (v > 0) return 1.f;
 * else return 0.f;
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))sign(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))sin(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))sin(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))sin(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))sin(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine and cosine of a value.
 *
 * @return sine of v
 * @param v The incoming value in radians
 * @param *cos cosptr[0] will be set to the cosine value.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((overloadable))sincos(float v, float* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine and cosine of a value.
 *
 * @return sine of v
 * @param v The incoming value in radians
 * @param *cos cosptr[0] will be set to the cosine value.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((overloadable))sincos(float2 v, float2* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine and cosine of a value.
 *
 * @return sine of v
 * @param v The incoming value in radians
 * @param *cos cosptr[0] will be set to the cosine value.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((overloadable))sincos(float3 v, float3* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine and cosine of a value.
 *
 * @return sine of v
 * @param v The incoming value in radians
 * @param *cos cosptr[0] will be set to the cosine value.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((overloadable))sincos(float4 v, float4* cos);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic sine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))sinh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic sine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))sinh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic sine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))sinh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic sine of v, where v is measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))sinh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))sinpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))sinpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))sinpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the sine of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the sine of a value measured in degrees, call sinpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))sinpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the square root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))sqrt(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the square root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))sqrt(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the square root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))sqrt(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the square root of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))sqrt(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a[i] < b[i]) ? 0.f : atan2(a[i], b[i]) for the corresponding elements of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))step(float edge, float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a[i] < b[i]) ? 0.f : atan2(a[i], b[i]) for the corresponding elements of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))step(float2 edge, float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a[i] < b[i]) ? 0.f : atan2(a[i], b[i]) for the corresponding elements of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))step(float3 edge, float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a[i] < b[i]) ? 0.f : atan2(a[i], b[i]) for the corresponding elements of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))step(float4 edge, float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a[i] < b) ? 0.f : atan2(a[i], b) for each element of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))step(float2 edge, float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a[i] < b) ? 0.f : atan2(a[i], b) for each element of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))step(float3 edge, float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a[i] < b) ? 0.f : atan2(a[i], b) for each element of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))step(float4 edge, float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a < b[i]) ? 0.f : atan2(a, b[i]) for each element of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 21 and newer.
 */
extern float2 __attribute__((const, overloadable))step(float edge, float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a < b[i]) ? 0.f : atan2(a, b[i]) for each element of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 21 and newer.
 */
extern float3 __attribute__((const, overloadable))step(float edge, float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 21))
/**
 * Returns 0.f if v < edge, 1.f otherwise.
 *
 * This can be useful to create conditional computations without using loops and branching instructions.  For example, instead of computing (a < b[i]) ? 0.f : atan2(a, b[i]) for each element of a vector, you could instead use step(a, b) * atan2(a, b).
 *
 * Supported by API versions 21 and newer.
 */
extern float4 __attribute__((const, overloadable))step(float edge, float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))tan(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))tan(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))tan(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of an angle measured in radians.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))tan(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic tangent of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))tanh(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic tangent of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))tanh(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic tangent of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))tanh(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the hyperbolic tangent of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))tanh(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))tanpi(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))tanpi(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))tanpi(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the tangent of (v * pi), where (v * pi) is measured in radians.
 *
 * To get the tangent of a value measured in degrees, call tanpi(v / 180.f).
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))tanpi(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the gamma function of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))tgamma(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the gamma function of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))tgamma(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the gamma function of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))tgamma(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Returns the gamma function of a value.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))tgamma(float4 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to integral using truncation.
 *
 * For example, trunc(1.7f) returns 1.f and trunc(-1.7f) returns -1.f.
 *
 * See rint() and round() for other rounding options.
 *
 * Supported by API versions 9 and newer.
 */
extern float __attribute__((const, overloadable))trunc(float v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to integral using truncation.
 *
 * For example, trunc(1.7f) returns 1.f and trunc(-1.7f) returns -1.f.
 *
 * See rint() and round() for other rounding options.
 *
 * Supported by API versions 9 and newer.
 */
extern float2 __attribute__((const, overloadable))trunc(float2 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to integral using truncation.
 *
 * For example, trunc(1.7f) returns 1.f and trunc(-1.7f) returns -1.f.
 *
 * See rint() and round() for other rounding options.
 *
 * Supported by API versions 9 and newer.
 */
extern float3 __attribute__((const, overloadable))trunc(float3 v);
#endif

#if (defined(RS_VERSION) && (RS_VERSION >= 9))
/**
 * Rounds to integral using truncation.
 *
 * For example, trunc(1.7f) returns 1.f and trunc(-1.7f) returns -1.f.
 *
 * See rint() and round() for other rounding options.
 *
 * Supported by API versions 9 and newer.
 */
extern float4 __attribute__((const, overloadable))trunc(float4 v);
#endif

#endif // __rs_core_math_rsh__
